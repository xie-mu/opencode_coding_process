# Music Vocal Concert 安全与合规清单

## 1. 安全规范

### 1.1 网络安全

#### 1.1.1 防火墙配置
```bash
# 防火墙规则
# 允许HTTP/HTTPS流量
sudo ufw allow 80/tcp
sudo ufw allow 443/tcp

# 允许SSH连接
sudo ufw allow 22/tcp

# 拒绝其他所有连接
sudo ufw deny all

# 启用防火墙
sudo ufw enable
```

#### 1.1.2 WAF配置
```nginx
# Nginx WAF配置
http {
    # 定义WAF规则
    geo $blocked_ip {
        default 0;
        # 阻止已知的恶意IP
        192.168.1.1 1;
        10.0.0.1 1;
    }

    server {
        listen 80;
        server_name _;

        # 阻止恶意IP
        if ($blocked_ip) {
            return 403;
        }

        # 阻止常见攻击
        location / {
            limit_req zone=api burst=5 nodelay;
            limit_req_status 429;
            limit_conn api_conn 10;
            limit_conn_status 503;
        }
    }
}
```

### 1.2 应用安全

#### 1.2.1 身份认证
```python
# JWT认证配置
from fastapi import FastAPI, Depends, HTTPException
from fastapi.security import OAuth2PasswordBearer
from jose import JWTError, jwt
from datetime import datetime, timedelta

SECRET_KEY = "your-secret-key-here"
ALGORITHM = "HS256"
ACCESS_TOKEN_EXPIRE_MINUTES = 30

oauth2_scheme = OAuth2PasswordBearer(tokenUrl="token")

def create_access_token(data: dict):
    to_encode = data.copy()
    expire = datetime.utcnow() + timedelta(minutes=ACCESS_TOKEN_EXPIRE_MINUTES)
    to_encode.update({"exp": expire})
    encoded_jwt = jwt.encode(to_encode, SECRET_KEY, algorithm=ALGORITHM)
    return encoded_jwt

async def get_current_user(token: str = Depends(oauth2_scheme)):
    credentials_exception = HTTPException(
        status_code=401,
        detail="Could not validate credentials",
        headers={"WWW-Authenticate": "Bearer"},
    )
    try:
        payload = jwt.decode(token, SECRET_KEY, algorithms=[ALGORITHM])
        username: str = payload.get("sub")
        if username is None:
            raise credentials_exception
    except JWTError:
        raise credentials_exception
    return username
```

#### 1.2.2 权限控制
```python
# RBAC权限控制
from enum import Enum
from typing import List

class Permission(str, Enum):
    READ_CONCERTS = "read:concerts"
    WRITE_CONCERTS = "write:concerts"
    DELETE_CONCERTS = "delete:concerts"
    ADMIN = "admin"

class Role(str, Enum):
    USER = "user"
    MODERATOR = "moderator"
    ADMIN = "admin"

ROLE_PERMISSIONS = {
    Role.USER: [Permission.READ_CONCERTS],
    Role.MODERATOR: [Permission.READ_CONCERTS, Permission.WRITE_CONCERTS],
    Role.ADMIN: [Permission.READ_CONCERTS, Permission.WRITE_CONCERTS, Permission.DELETE_CONCERTS, Permission.ADMIN]
}

def require_permission(permission: Permission):
    def decorator(func):
        @wraps(func)
        async def wrapper(*args, **kwargs):
            current_user = kwargs.get('current_user')
            if not current_user:
                raise HTTPException(status_code=401, detail="Not authenticated")
            
            user_permissions = ROLE_PERMISSIONS.get(current_user.role, [])
            if permission not in user_permissions:
                raise HTTPException(status_code=403, detail="Insufficient permissions")
            
            return await func(*args, **kwargs)
        return wrapper
    return decorator
```

#### 1.2.3 输入验证
```python
# 输入验证
from pydantic import BaseModel, validator
from datetime import datetime
from typing import Optional

class ConcertCreate(BaseModel):
    name: str = Field(..., min_length=1, max_length=200)
    artist: str = Field(..., min_length=1, max_length=100)
    city: str = Field(..., min_length=1, max_length=50)
    date: datetime
    address: str = Field(..., min_length=1, max_length=300)
    venue: str = Field(..., min_length=1, max_length=100)
    platform: str = Field(..., min_length=1, max_length=50)

    @validator('name', 'artist', 'city', 'address', 'venue', 'platform')
    def validate_no_html(cls, v):
        """防止HTML注入"""
        import html
        return html.escape(v)

    @validator('date')
    def validate_date(cls, v):
        """验证日期"""
        if v < datetime.now():
            raise ValueError('演唱会日期不能早于当前时间')
        return v
```

#### 1.2.4 输出编码
```python
# 输出编码
from fastapi import Response
from typing import Any

def safe_json_response(data: Any) -> Response:
    """安全的JSON响应"""
    import json
    import html
    
    # 递归处理数据，防止XSS
    def escape_data(obj):
        if isinstance(obj, str):
            return html.escape(obj)
        elif isinstance(obj, dict):
            return {k: escape_data(v) for k, v in obj.items()}
        elif isinstance(obj, list):
            return [escape_data(item) for item in obj]
        else:
            return obj
    
    safe_data = escape_data(data)
    return Response(
        content=json.dumps(safe_data, ensure_ascii=False),
        media_type="application/json"
    )
```

### 1.3 数据安全

#### 1.3.1 数据加密
```python
# 数据加密
from cryptography.fernet import Fernet
from cryptography.hazmat.primitives import hashes
from cryptography.hazmat.primitives.kdf.pbkdf2 import PBKDF2HMAC
import base64
import os

class DataEncryption:
    def __init__(self, password: str):
        salt = b'salt_1234567890'  # 生产环境应使用随机salt
        kdf = PBKDF2HMAC(
            algorithm=hashes.SHA256(),
            length=32,
            salt=salt,
            iterations=100000,
        )
        key = base64.urlsafe_b64encode(kdf.derive(password.encode()))
        self.cipher = Fernet(key)

    def encrypt(self, data: str) -> str:
        """加密数据"""
        encrypted_data = self.cipher.encrypt(data.encode())
        return base64.urlsafe_b64encode(encrypted_data).decode()

    def decrypt(self, encrypted_data: str) -> str:
        """解密数据"""
        encrypted_bytes = base64.urlsafe_b64decode(encrypted_data.encode())
        decrypted_data = self.cipher.decrypt(encrypted_bytes)
        return decrypted_data.decode()
```

#### 1.3.2 敏感数据保护
```python
# 敏感数据保护
import logging
from functools import wraps

class SensitiveDataLogger:
    def __init__(self):
        self.logger = logging.getLogger(__name__)

    def sanitize_log(self, data: dict) -> dict:
        """脱敏日志数据"""
        sanitized = data.copy()
        sensitive_fields = ['password', 'token', 'secret', 'key']
        
        for field in sensitive_fields:
            if field in sanitized:
                sanitized[field] = '***REDACTED***'
        
        return sanitized

    def log_sensitive_operation(self, operation: str, data: dict):
        """记录敏感操作日志"""
        sanitized_data = self.sanitize_log(data)
        self.logger.info(f"Sensitive operation: {operation}", extra=sanitized_data)
```

### 1.4 日志安全

#### 1.4.1 日志配置
```python
# 日志配置
import logging
import logging.config
from pythonjsonlogger import jsonlogger

LOGGING_CONFIG = {
    'version': 1,
    'disable_existing_loggers': False,
    'formatters': {
        'json': {
            '()': 'pythonjsonlogger.jsonlogger.JsonFormatter',
            'format': '%(asctime)s %(name)s %(levelname)s %(message)s %(module)s %(funcName)s %(lineno)d'
        },
        'standard': {
            'format': '%(asctime)s [%(levelname)s] %(name)s: %(message)s'
        },
    },
    'handlers': {
        'default': {
            'level': 'INFO',
            'formatter': 'json',
            'class': 'logging.handlers.RotatingFileHandler',
            'filename': 'logs/app.log',
            'maxBytes': 10485760,  # 10MB
            'backupCount': 10,
        },
        'security': {
            'level': 'WARNING',
            'formatter': 'standard',
            'class': 'logging.handlers.RotatingFileHandler',
            'filename': 'logs/security.log',
            'maxBytes': 10485760,
            'backupCount': 10,
        },
    },
    'loggers': {
        '': {
            'handlers': ['default'],
            'level': 'INFO',
            'propagate': True
        },
        'security': {
            'handlers': ['security'],
            'level': 'WARNING',
            'propagate': False
        }
    }
}

logging.config.dictConfig(LOGGING_CONFIG)
```

#### 1.4.2 安全日志记录
```python
# 安全日志记录
import logging
from datetime import datetime

security_logger = logging.getLogger('security')

def log_security_event(event_type: str, user_id: str = None, ip_address: str = None, details: dict = None):
    """记录安全事件"""
    security_logger.warning(
        f"Security event: {event_type}",
        extra={
            'event_type': event_type,
            'user_id': user_id,
            'ip_address': ip_address,
            'timestamp': datetime.now().isoformat(),
            'details': details or {}
        }
    )
```

## 2. 合规要求

### 2.1 数据保护法规

#### 2.1.1 GDPR合规
```python
# GDPR合规
from typing import Optional
from datetime import datetime, timedelta

class GDPRCompliance:
    def __init__(self):
        self.retention_period = timedelta(days=365)  # 数据保留1年

    def get_user_data(self, user_id: str) -> dict:
        """获取用户数据"""
        # 实现数据访问控制
        pass

    def delete_user_data(self, user_id: str) -> bool:
        """删除用户数据"""
        # 实现数据删除功能
        pass

    def export_user_data(self, user_id: str) -> dict:
        """导出用户数据"""
        # 实现数据导出功能
        pass

    def anonymize_data(self, user_id: str) -> bool:
        """匿名化用户数据"""
        # 实现数据匿名化
        pass
```

#### 2.1.2 个人信息保护
```python
# 个人信息保护
from typing import Optional
import hashlib

class PersonalDataProtection:
    def __init__(self):
        self.salt = "your-salt-here"

    def hash_personal_data(self, data: str) -> str:
        """哈希处理个人信息"""
        return hashlib.sha256((data + self.salt).encode()).hexdigest()

    def mask_email(self, email: str) -> str:
        """掩码处理邮箱"""
        if '@' not in email:
            return email
        username, domain = email.split('@')
        if len(username) <= 2:
            return email
        masked_username = username[0] + '*' * (len(username) - 2) + username[-1]
        return f"{masked_username}@{domain}"

    def mask_phone(self, phone: str) -> str:
        """掩码处理手机号"""
        if len(phone) <= 4:
            return phone
        return phone[:3] + '*' * (len(phone) - 6) + phone[-3:]
```

### 2.2 行业标准

#### 2.2.1 ISO 27001
```python
# ISO 27001合规
class ISO27001Compliance:
    def __init__(self):
        self.security_controls = {
            'access_control': self._check_access_control,
            'data_classification': self._check_data_classification,
            'incident_response': self._check_incident_response,
            'business_continuity': self._check_business_continuity
        }

    def _check_access_control(self) -> bool:
        """检查访问控制"""
        # 实现访问控制检查
        return True

    def _check_data_classification(self) -> bool:
        """检查数据分类"""
        # 实现数据分类检查
        return True

    def _check_incident_response(self) -> bool:
        """检查事件响应"""
        # 实现事件响应检查
        return True

    def _check_business_continuity(self) -> bool:
        """检查业务连续性"""
        # 实现业务连续性检查
        return True

    def perform_security_assessment(self) -> dict:
        """执行安全评估"""
        results = {}
        for control, check_func in self.security_controls.items():
            results[control] = check_func()
        return results
```

#### 2.2.2 PCI DSS
```python
# PCI DSS合规
class PCIDSSCompliance:
    def __init__(self):
        self.requirements = {
            '1': '建立和维护一个安全的网络',
            '2': '保护持卡人数据',
            '3': '维护漏洞管理程序',
            '4': '实施强访问控制措施',
            '5': '定期监控和测试网络',
            '6': '维护信息安全政策'
        }

    def check_requirement(self, requirement_id: str) -> bool:
        """检查特定要求"""
        # 实现具体要求检查
        return True

    def generate_compliance_report(self) -> dict:
        """生成合规报告"""
        report = {}
        for req_id, description in self.requirements.items():
            report[req_id] = {
                'description': description,
                'status': self.check_requirement(req_id),
                'evidence': f'Evidence for requirement {req_id}'
            }
        return report
```

## 3. 安全审计

### 3.1 安全扫描

#### 3.1.1 代码扫描
```bash
# 代码扫描工具
# 安装安全扫描工具
pip install bandit safety

# 运行代码安全扫描
bandit -r src/ -f json -o bandit-report.json

# 检查依赖安全
safety check -r requirements.txt --json
```

#### 3.1.2 依赖扫描
```bash
# 依赖扫描
# 使用pip-audit
pip install pip-audit

# 扫描依赖漏洞
pip-audit --format json --output audit-report.json

# 使用OWASP Dependency-Check
# 下载并配置OWASP Dependency-Check
java -jar dependency-check.jar --project "Music Vocal Concert" --scan . --format JSON --out dependency-check-report.json
```

### 3.2 漏洞管理

#### 3.2.1 漏洞扫描
```bash
# 漏洞扫描
# 使用Nessus
# 配置Nessus扫描策略
# 执行扫描并生成报告

# 使用OpenVAS
# 配置OpenVAS扫描策略
# 执行扫描并生成报告

# 使用Nmap
# 端口扫描
nmap -sV -p 1-65535 localhost

# 漏洞扫描
nmap --script vuln localhost
```

#### 3.2.2 漏洞修复
```python
# 漏洞修复
class VulnerabilityFixer:
    def __init__(self):
        self.vulnerabilities = []

    def add_vulnerability(self, vulnerability: dict):
        """添加漏洞"""
        self.vulnerabilities.append(vulnerability)

    def fix_vulnerability(self, vulnerability_id: str) -> bool:
        """修复漏洞"""
        # 实现漏洞修复
        return True

    def generate_fix_report(self) -> dict:
        """生成修复报告"""
        return {
            'total_vulnerabilities': len(self.vulnerabilities),
            'fixed_vulnerabilities': sum(1 for v in self.vulnerabilities if v.get('fixed', False)),
            'remaining_vulnerabilities': sum(1 for v in self.vulnerabilities if not v.get('fixed', False))
        }
```

## 4. 应急响应

### 4.1 安全事件响应

#### 4.1.1 事件检测
```python
# 安全事件检测
import re
from datetime import datetime, timedelta

class SecurityEventDetector:
    def __init__(self):
        self.suspicious_patterns = [
            r'<script.*?>.*?</script>',
            r'union\s+select',
            r'insert\s+into',
            r'drop\s+table',
            r'exec\s*\(',
            r'system\s*\('
        ]

    def detect_sql_injection(self, input_data: str) -> bool:
        """检测SQL注入"""
        for pattern in self.suspicious_patterns:
            if re.search(pattern, input_data, re.IGNORECASE):
                return True
        return False

    def detect_xss_attack(self, input_data: str) -> bool:
        """检测XSS攻击"""
        xss_patterns = [
            r'<script.*?>.*?</script>',
            r'javascript:',
            r'on\w+\s*=',
            r'eval\s*\('
        ]
        for pattern in xss_patterns:
            if re.search(pattern, input_data, re.IGNORECASE):
                return True
        return False

    def detect_brute_force(self, login_attempts: list) -> bool:
        """检测暴力破解"""
        recent_attempts = [attempt for attempt in login_attempts 
                          if attempt['timestamp'] > datetime.now() - timedelta(minutes=5)]
        return len(recent_attempts) > 10
```

#### 4.1.2 事件响应
```python
# 安全事件响应
class SecurityEventResponder:
    def __init__(self):
        self.responder = SecurityEventDetector()

    def handle_security_event(self, event_type: str, details: dict) -> dict:
        """处理安全事件"""
        response = {
            'event_type': event_type,
            'timestamp': datetime.now().isoformat(),
            'details': details,
            'action_taken': [],
            'status': 'investigating'
        }

        if event_type == 'sql_injection':
            response['action_taken'].append('Blocked suspicious SQL query')
            response['action_taken'].append('Logged attacker IP address')
            response['action_taken'].append('Sent alert to security team')
            response['status'] = 'contained'

        elif event_type == 'xss_attack':
            response['action_taken'].append('Blocked malicious script')
            response['action_taken'].append('Logged attacker information')
            response['action_taken'].append('Sanitized input data')
            response['status'] = 'contained'

        elif event_type == 'brute_force':
            response['action_taken'].append('Blocked IP address')
            response['action_taken'].append('Increased login attempt limit')
            response['action_taken'].append('Sent alert to security team')
            response['status'] = 'contained'

        return response
```

### 4.2 灾难恢复

#### 4.2.1 备份策略
```python
# 备份策略
import os
import shutil
from datetime import datetime

class BackupStrategy:
    def __init__(self):
        self.backup_dir = '/var/backups/music-vocal-concert'
        self.retention_days = 30

    def create_database_backup(self) -> str:
        """创建数据库备份"""
        timestamp = datetime.now().strftime('%Y%m%d_%H%M%S')
        backup_file = f'{self.backup_dir}/db_backup_{timestamp}.sql'
        
        # 创建数据库备份
        os.system(f'pg_dump music_vocal_concert > {backup_file}')
        
        # 压缩备份文件
        os.system(f'gzip {backup_file}')
        
        return f'{backup_file}.gz'

    def create_file_backup(self) -> str:
        """创建文件备份"""
        timestamp = datetime.now().strftime('%Y%m%d_%H%M%S')
        backup_dir = f'{self.backup_dir}/files_{timestamp}'
        
        # 创建文件备份
        shutil.copytree('/var/www/music-vocal-concert', backup_dir)
        
        return backup_dir

    def cleanup_old_backups(self):
        """清理旧备份"""
        # 清理超过保留期限的备份
        pass
```

#### 4.2.2 恢复测试
```python
# 恢复测试
class RecoveryTest:
    def __init__(self):
        self.backup_strategy = BackupStrategy()

    def test_database_recovery(self) -> dict:
        """测试数据库恢复"""
        test_result = {
            'test_type': 'database_recovery',
            'timestamp': datetime.now().isoformat(),
            'status': 'running',
            'steps': []
        }

        try:
            # 创建测试备份
            backup_file = self.backup_strategy.create_database_backup()
            test_result['steps'].append(f'Created backup: {backup_file}')

            # 模拟数据损坏
            os.system('dropdb music_vocal_concert_test')
            test_result['steps'].append('Simulated database corruption')

            # 恢复数据库
            os.system(f'gunzip -c {backup_file} | psql music_vocal_concert_test')
            test_result['steps'].append('Restored database from backup')

            # 验证恢复结果
            result = os.popen('psql music_vocal_concert_test -c "SELECT COUNT(*) FROM concerts;"').read()
            test_result['steps'].append(f'Verified recovery: {result.strip()}')

            test_result['status'] = 'passed'
            test_result['details'] = 'Database recovery test passed'

        except Exception as e:
            test_result['status'] = 'failed'
            test_result['error'] = str(e)

        return test_result
```

## 5. 安全监控

### 5.1 实时监控

#### 5.1.1 安全监控
```python
# 安全监控
import psutil
import time
from datetime import datetime

class SecurityMonitor:
    def __init__(self):
        self.thresholds = {
            'cpu_usage': 80,  # CPU使用率阈值
            'memory_usage': 85,  # 内存使用率阈值
            'disk_usage': 90,  # 磁盘使用率阈值
            'failed_logins': 5  # 失败登录次数阈值
        }

    def monitor_system_resources(self) -> dict:
        """监控系统资源"""
        cpu_usage = psutil.cpu_percent(interval=1)
        memory_usage = psutil.virtual_memory().percent
        disk_usage = psutil.disk_usage('/').percent

        alerts = []
        if cpu_usage > self.thresholds['cpu_usage']:
            alerts.append(f'High CPU usage: {cpu_usage}%')
        if memory_usage > self.thresholds['memory_usage']:
            alerts.append(f'High memory usage: {memory_usage}%')
        if disk_usage > self.thresholds['disk_usage']:
            alerts.append(f'High disk usage: {disk_usage}%')

        return {
            'timestamp': datetime.now().isoformat(),
            'cpu_usage': cpu_usage,
            'memory_usage': memory_usage,
            'disk_usage': disk_usage,
            'alerts': alerts
        }

    def monitor_failed_logins(self) -> dict:
        """监控失败登录"""
        # 实现失败登录监控
        pass
```

#### 5.1.2 日志监控
```python
# 日志监控
import re
from datetime import datetime, timedelta

class LogMonitor:
    def __init__(self):
        self.suspicious_patterns = [
            r'union\s+select',
            r'insert\s+into',
            r'drop\s+table',
            r'exec\s*\(',
            r'javascript:'
        ]

    def monitor_logs(self, log_file: str) -> list:
        """监控日志文件"""
        alerts = []
        suspicious_events = []

        try:
            with open(log_file, 'r') as f:
                for line in f:
                    for pattern in self.suspicious_patterns:
                        if re.search(pattern, line, re.IGNORECASE):
                            alert = {
                                'timestamp': datetime.now().isoformat(),
                                'log_line': line.strip(),
                                'pattern': pattern,
                                'severity': 'high'
                            }
                            alerts.append(alert)
                            suspicious_events.append(line.strip())
                            break
        except FileNotFoundError:
            pass

        return {
            'total_alerts': len(alerts),
            'alerts': alerts,
            'suspicious_events': suspicious_events
        }
```

## 6. 附录

### 6.1 安全工具
- **Nessus**: 漏洞扫描工具
- **OpenVAS**: 漏洞评估系统
- **Nmap**: 网络扫描工具
- **Burp Suite**: Web应用安全测试
- **OWASP ZAP**: Web应用安全扫描

### 6.2 合规标准
- **GDPR**: 通用数据保护条例
- **ISO 27001**: 信息安全管理体系
- **PCI DSS**: 支付卡行业数据安全标准
- **SOC 2**: 服务组织控制报告
- **HIPAA**: 健康保险可携性和责任法案

### 6.3 参考文档
- **OWASP Top 10**: Web应用安全风险
- **NIST Cybersecurity Framework**: 网络安全框架
- **CIS Controls**: 网络安全基准控制
- **ISO/IEC 27002**: 信息安全控制实践指南

**文档版本**: 1.0
**创建时间**: 2026-02-08
**最后更新**: 2026-02-08 23:57:00